* Преговор за 4 + 1 изгледа за една софтуерна система 

	Това е стандартен метод за описване на архитектура на една софтуерна система. 
	Моделът предлага 4 различни перспективи, които заедно дават пълна и ясна картина.
	
	Какво представлява различни изгледи на този модел:
	- Логически изглед (Logical View): Фокусира се върху функционалността, която системата предоставя на потребителя.
	Описва от какви основни градивни блокове (като класове, компоненти) е изградена системата и какви са вързките между тях.
	
	- Излгед на кода/разработка (Development view): Това е перспектива за програмистта и показва как софтуерът е организиран между 
	модули, библиотеки и подсистеми в средата за разработка. 
	
	- Процесен изглед (Process View): Този изглед се фокусира върху държането на системата по време на изпълнение.
	Описват се основните процеси и нишки и как те комуникират помежду си и как се справят с проблемите.

	- Физически изглед (Deployment view): Описва как софтуерните компоненти се разполагат върху физическия хардуер (сървъри, мрежови устройсва)
	
	- +1 изгледа: Разглеждат се различните use cases, които описват последователността от взаимодействията между компонентите на системата
	
* Повече относно логически изглед на софутерна архитектура 

	Един логически изглед на една система има 4ри нива на абстракция:
	- Компоненти и конектори 
	- Техните интерфейси 
	- Архитектурни конфигуриации: конкретна схема на свързване на софтуерна системаде
	- Архитектурни стилове: (patterns) за успесни практически доказани архитектурни конфигурации 
	
* Дефиниция за софтуерен компонент 
	
	Това е изчислителна софтуерна единица, която има определена фунцкионалност, която е достъпна чрез добре дефинирани интерфейси и има изрично специфирани зависимости 
	
	Има входен интерфейс (required interface) който определя какво се нуждае компонента, за да изпълни своята функционалност
	(с други думи interface който приема входни данни)
	
	Има изходен интефейс (provided inteface) който уточнява какво произвоежда компонента като резултат, при условие, че всичко от спецификацията на входния интефейс и изпълнено 
	(с други думи interface който изпраща изходни данни) 
	
* Софтуерен конектор 

	First class entity (първокласен обект) е елемент, който може да:
	- бъде създаден по време на компилация
	- бъде подаван като параметър на функция
	- да бъде връщан като резултат от функция 
	- да му бъде присвоявана стойност в променлива 
	(Буквално си го престави като обект, който просто е създаден по време на изпълнението на програмата)
	
	Тогава софтуерният конектор (first calss entity) е механизъм, който представлява протокола на взаимодействие и правилата за комуникацията 
	между 2 софтуерни компонентта (тоест управлява как компонентите си говорят)
	
	Конекторите моделират статични и динамичните аспекти на взаимодействието между компонентните интерфейси 
	Един конектор също е възможно да има интерфейс, той се нарича роля
	
* Разлики между компонент и конектор 

	Спрямо зависимостта: 
	- Компонентите осигуряват за приложенито функционалност или application-independent инфраструктура (тоест функционалността да си е независимоа)
	- Коненкторите осигуряват независимо от приложението механизми за взаймодействие (тоест те помагат на компонентите да се свържат)
	
	Спрямо кода:
	- Компонентите могат да бъдат намерени имплементирани в кода 
	- Конeкторите са механизми за комуникаця, които може да се осъществи чрез мрежова връзка, извикване на фунцкия от външна библиотека 
	
	Спрямо абстракцията:
	- Компонентите осигуряват абстракция на групирането на функционалности 
	- Конекторите осигуряват абстракция на взаймодействието на тези компоненти 
	
* Софтуерните конектори и взаймодействието между софтуерните компоненти 

	Всеки конектор има своя собствена "спецификация на протокол", тоест набор от правила, който определят свойствата на конектора 
	и как точно ще се случи комуникацията.
	
	Тези правила включват:
	- Какво типове интерфейси може да свързва, може примерно конекторът да е съвместим с "синхронни" или "асинхронни" интерфейси 
	- Конекторът може да дава определени гаранции при комуникацията примерно дали всяко съобщение ще бъде доставено или други гаранции 
	- Конекторът може да определи реда на операциите например коя стъпка следва след коя 
	- Конекторът може да определи колко да е бърза връзката, дали данните са криптирани 
	
	
	