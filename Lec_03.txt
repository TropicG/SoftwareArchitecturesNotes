* Преговор за 4 + 1 изгледа за една софтуерна система 

	Това е стандартен метод за описване на архитектура на една софтуерна система. 
	Моделът предлага 4 различни перспективи, които заедно дават пълна и ясна картина.
	
	Какво представлява различни изгледи на този модел:
	- Логически изглед (Logical View): Фокусира се върху функционалността, която системата предоставя на потребителя.
	Описва от какви основни градивни блокове (като класове, компоненти) е изградена системата и какви са вързките между тях.
	
	- Излгед на кода/разработка (Development view): Това е перспектива за програмистта и показва как софтуерът е организиран между 
	модули, библиотеки и подсистеми в средата за разработка. 
	
	- Процесен изглед (Process View): Този изглед се фокусира върху държането на системата по време на изпълнение.
	Описват се основните процеси и нишки и как те комуникират помежду си и как се справят с проблемите.

	- Физически изглед (Deployment view): Описва как софтуерните компоненти се разполагат върху физическия хардуер (сървъри, мрежови устройсва)
	
	- +1 изгледа: Разглеждат се различните use cases, които описват последователността от взаимодействията между компонентите на системата
	
* Повече относно логически изглед на софутерна архитектура 

	Един логически изглед на една система има 4ри нива на абстракция:
	- Компоненти и конектори 
	- Техните интерфейси 
	- Архитектурни конфигуриации: конкретна схема на свързване на софтуерна системаде
	- Архитектурни стилове: (patterns) за успесни практически доказани архитектурни конфигурации 
	
* Дефиниция за софтуерен компонент 
	
	Това е изчислителна софтуерна единица, която има определена фунцкионалност, която е достъпна чрез добре дефинирани интерфейси и има изрично специфирани зависимости 
	
	Има входен интерфейс (required interface) който определя какво се нуждае компонента, за да изпълни своята функционалност
	(с други думи interface който приема входни данни)
	
	Има изходен интефейс (provided inteface) който уточнява какво произвоежда компонента като резултат, при условие, че всичко от спецификацията на входния интефейс и изпълнено 
	(с други думи interface който изпраща изходни данни) 
	
* Софтуерен конектор 

	First class entity (първокласен обект) е елемент, който може да:
	- бъде създаден по време на компилация
	- бъде подаван като параметър на функция
	- да бъде връщан като резултат от функция 
	- да му бъде присвоявана стойност в променлива 
	(Буквално си го престави като обект, който просто е създаден по време на изпълнението на програмата)
	
	Тогава софтуерният конектор (first calss entity) е механизъм, който представлява протокола на взаимодействие и правилата за комуникацията 
	между 2 софтуерни компонентта (тоест управлява как компонентите си говорят)
	
	Конекторите моделират статични и динамичните аспекти на взаимодействието между компонентните интерфейси 
	Един конектор също е възможно да има интерфейс, той се нарича роля
	
* Разлики между компонент и конектор 

	Спрямо зависимостта: 
	- Компонентите осигуряват за приложенито функционалност или application-independent инфраструктура (тоест функционалността да си е независимоа)
	- Коненкторите осигуряват независимо от приложението механизми за взаймодействие (тоест те помагат на компонентите да се свържат)
	
	Спрямо кода:
	- Компонентите могат да бъдат намерени имплементирани в кода 
	- Конeкторите са механизми за комуникаця, които може да се осъществи чрез мрежова връзка, извикване на фунцкия от външна библиотека 
	
	Спрямо абстракцията:
	- Компонентите осигуряват абстракция на групирането на функционалности 
	- Конекторите осигуряват абстракция на взаймодействието на тези компоненти 
	
* Софтуерните конектори и взаймодействието между софтуерните компоненти 

	Всеки конектор има своя собствена "спецификация на протокол", тоест набор от правила, който определят свойствата на конектора 
	и как точно ще се случи комуникацията.
	
	Тези правила включват:
	- Какво типове интерфейси може да свързва, може примерно конекторът да е съвместим с "синхронни" или "асинхронни" интерфейси 
	- Конекторът може да дава определени гаранции при комуникацията примерно дали всяко съобщение ще бъде доставено или други гаранции 
	- Конекторът може да определи реда на операциите например коя стъпка следва след коя 
	- Конекторът може да определи колко да е бърза връзката, дали данните са криптирани 
	
* Пример за конектор 

	Реално връзката между компоненти не е винаги прост от сорта на компонент А комуникира с компонент Б, реално сложността може да бъди много по голяма
	
	Всъщност връзката между А и Б се извършва чрез конектор, този конектор участва в комуникацията (даже я направлява, дори може да включи и друг компонент в комуникацията)
	
* Видове конектори

	Видовете се делят на два типа: прости и сложни взаймодействия 
	
	Простите взаимодействия са като еднократна или директна команда, докато сложните конектори са като цял разговор със сложни правила 
	
	Примери за просто конектори:
	- Отдалечено извикване на процедура (RPC): един компонент нарежда на друг да изпълни конкретна функция и чака резултат все едно е локална функция 
	- Достъп до споделни променливи (shared variables): един компонент записва някакви данни в паметта на системата, а друг чете оттам и комуникацията си остава базова 
	
	Пример за сложни и семантично-богати взаимодействия:
	- Клиент-сървър проколи: протокола може да включва установяване на връзка, пращане на различни заявки (POST, GET), управление на сесии и сложен формат за предаване на данни 
	- Протоколи за достъп до БД: протокола включва стъпки от установяване на връзка с сървъра, пращане на заявки на SQL, получаване на структурираните данни 
	
* Роли на конекторите 

	Конекторите могат да изпълняват няколко роли в една софтуерна система:
	- Комуникация: тук конектора осигурява самия пренос на данни, като разделя логиката на комуникацията от изчислителната система на компонентите 
	- Координация: в тази роля конекторът определя и управлява потока на контрол и последователността на операциите между компонентите 
	- Преобразуване: един конектор може да помага на несъвместими компоненти да работят заедно като преобразува формата от единия компонент във формата на другия 
	- Улесняване: може да оптимизира и улеснява взаймодействието като управлява ресурсите или осигурява допълнителни услуги
	
* Конекторите като комуникации 

	Както споменахме конекторите позволяват да се раздели комуникационната логика от компонентите, за да могат да се фокусират върху другата си функционалност 
	
	Конекторите могат да имат пряко влияние върху нефункционалните характеристики на системата като примерно нейната производителност, мащабируемост 
	
	Конекторите могат да реализират следните начини за комуникация: RPC и message passing (предаване на съобщения)
	
	Конекторите имат и възможността да налагат ограничения върху комникацията, може да принуди данните да текат само в една посока (като при pipes) 
	или да гарантира определено качество (примерно данните да не бъдат загубени)
	
	Пример: Нормален RPC call 
	Клеинтът изпраща заявката си към сървъра 
	Сървира получава заявката и изпълнява процедурата (функцията) и изпраща обратно резултата
	Клиентът получава резултата и продължава своята работа 
	
* Конекторите като координатори 

	Конекторите могат да зададат правила как да се предават данните и в каква последователно
	
	Пример:
	Представи си, че имаш примерно клиент, който използва дадена структура и иска да си направи заявката с данните 
	Вместо директно да се свърже с компонента, който иска той предава данните на коненктор компонента (да кажем, че се казва контролер)
	Контролер компонента взима данните и получената заявка от клиента и ги обработва и кординира тяхното изпращане 
	Именно този контролер знае как да комуникира директно с финалната точка 
	
* Конекторите като конвертори 

	Основната цел на тази роля на конектор е да направи възможно комуникирането между несъвместими компоненти 
	
	Конекторите могат да разрешават несъответствия като например различни типове данни, различаен брой параметри или различен ред
	

	


	